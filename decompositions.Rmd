---
title: "Decompositions"
author: "Sophie Woodward"
date: '2023-06-08'
output:
  pdf_document:
    fig_width: 6
    fig_height: 3
    toc: yes
geometry: margin=1cm
---

```{r, include = F}
source('funcs.R')
library(raster)
library(fields)

if (!file.exists('out.Rdata')){
  source('runsim.R')
}
load('out.Rdata')
```

# Plot grid
```{r}
png("images/grid1.jpeg")
r <- raster(xmn = 0, xmx = 27, ymn = 0, ymx = 27, nrows = 3, ncols = 3)
r[] <- sample(1:9)
plot(r, legend = F)
dev.off()

png("images/grid2.jpeg")
r <- raster(xmn = 0, xmx = 27, ymn = 0, ymx = 27, nrows = 9, ncols = 9)
r[] <- sample(1:81)
plot(r, legend = F)
dev.off()

png("images/grid3.jpeg")
r <- raster(xmn = 0, xmx = 27, ymn = 0, ymx = 27, nrows = 27, ncols = 27)
r[] <- sample(1:729)
plot(r, legend = F)
dev.off()
```

# Plot eigenvectors by eigenvalue
```{r, eigenplots, cache = T, echo = F, message = F, results = 'hide', warning = F}
if (file.exists('outsim.Rdata')){
  load('outsim.Rdata')
  # extract eigen
  R = diag(rowSums(outsim$A)) - outsim$A # graph laplacian 
  E = eigen(R) # eigen component
  D = E$val
  G = E$vec
  png("images/eigenR.jpeg", height = 700, width = 1200, res = 100)
par(mfrow = c(3,6))
  for (j in 1:18){
    ix = 40*(j-1)+1
    z = G[,ix]
    image.plot(x=1:27, y=1:27, z = matrix(z, nrow = 27,ncol = 27), 
               main = paste('lambda =', round(D[ix],2)), col = viridis(n = 20), zlim = c(-0.10, 0.10))
    #dfr = rasterFromXYZ(cbind.data.frame(outsim$coord, z))    
    #image(dfr, main = paste('lambda =', round(D[ix],2)))
  }
dev.off()
}
```

# Visualization of X and Z
```{r}
if (file.exists('outsim.Rdata')){
  load('outsim.Rdata')
  nest = nested_decomp_mats(outsim$groups)
  X = outsim$X
  Z = outsim$Z
  X1 = nest$decomp_mats[[1]] %*% X
  X2 = nest$decomp_mats[[2]] %*% X
  X3 = nest$decomp_mats[[3]] %*% X
  Z1 = nest$decomp_mats[[1]] %*% Z
  Z2 = nest$decomp_mats[[2]] %*% Z
  Z3 = nest$decomp_mats[[3]] %*% Z
  png("images/XZ.jpeg", width = 1000, height = 600, res = 100)
  par(mfrow = c(2,4))
  dfr = rasterFromXYZ(cbind.data.frame(outsim$coord, X1))    
  image(dfr, main = 'X(1)', xlab = '', ylab = '')
  dfr = rasterFromXYZ(cbind.data.frame(outsim$coord, X2))              
  image(dfr, main = 'X(2)', xlab = '', ylab = '')
  dfr = rasterFromXYZ(cbind.data.frame(outsim$coord, X3))              
  image(dfr, main = 'X(3)', xlab = '', ylab = '')
  dfr = rasterFromXYZ(cbind.data.frame(outsim$coord, X))              
  image(dfr, main = 'X', xlab = '', ylab = '')
  dfr = rasterFromXYZ(cbind.data.frame(outsim$coord, Z1))              
  image(dfr, main = 'Z(1)', xlab = '', ylab = '')
  dfr = rasterFromXYZ(cbind.data.frame(outsim$coord, Z2))              
  image(dfr, main = 'Z(2)', xlab = '', ylab = '')
  dfr = rasterFromXYZ(cbind.data.frame(outsim$coord, Z3))              
  image(dfr, main = 'Z(3)', xlab = '', ylab = '')
  dfr = rasterFromXYZ(cbind.data.frame(outsim$coord, Z))              
  image(dfr, main = 'Z', xlab = '', ylab = '')
  dev.off()
  
  png(filename = 'images/XZhist.jpeg', width = 1000, height = 500)
  par(mfrow = c(1,2))
  hist(Z)
  hist(X)
  dev.off()
}
```



# Key Findings (CHANGES NEEDED)
\begin{itemize}
\item When the data-generating mechanism is based on the \textbf{nested} decomposition, the outcome model is \textbf{linear}, and confounding dissipates \textbf{locally} (within $5 \times 5$ grids), both the nested and spectral decompositions recover unbiased estimates of the treatment effect at small spatial scales.
\item When the data-generating mechanism is based on the \textbf{spectral} decomposition, the outcome model is \textbf{linear}, and confounding dissipates \textbf{locally} (at high spectral frequencies), the spectral decomposition recovers unbiased estimates of the treatment effect at small spatial scales. If the spectral correlation of exposure and confounder is equal to zero up to a small-enough frequency (big-enough spatial scale) the nested decomposition recovers nearly unbiased estimates at small spatial scales as well.
\item When the data-generating mechanism is based on the \textbf{nested} decomposition, the outcome model is \textbf{linear}, and confounding dissipates \textbf{globally} (confounding within $5 \times 5$ grids but not across), I thought the plots would be the same as the previous, but x axis (spatial scale) flipped. They are not exactly.
\item When there is an \textbf{interaction} between $X$ and $Z$ but confounding still dissipates locally, there is still near-zero bias at small spatial scales under both DGMs. At higher spatial scales bias is worse.
\item Neither decomposition can recover unbiased estimates at any scale when there is a \textbf{quadratic} term of exposure $X$ is included in the outcome model.
\end{itemize}

**Note**: in the following plots, I mark the x axis by spatial scale. If I plot results from the nested decomposition, then there are only two points: spatial scale equal to $1$ is the so-called county level ($1 \times 1$ grid) and spatial scale equal to $2$ is the so-called state level ($5 \times 5$ grid). If I plot results from the spectral decomposition, then the spatial scale indexes the ordered eigenvalues of the graph Laplacian. So the spatial scales between spectral and nested plots should not be directly compared. 

\newpage
# Simulation 1: Nested DGM
Denote $X$ as exposure $X$, $Z$ as unmeasured confounder, and $Y$ as outcome. 
We simulate the following scenario 100 times. 
\begin{enumerate}
\item Generate $n = 729$ observations of $Z \sim \text{Expo}(1)$.
\item Decompose $Z$ using the nested decomposition with three levels: 
\begin{align*}
Z(1) &= E(Z|L_1),\\
Z(2) &= E(Z|L_2)-Z(1)\\
Z(3) &= Z - Z(1) - Z(2)
\end{align*}
where $L_1$ is a random variable that maps each of the 729 units to their corresponding $9 \times 9$ grid (call this a state) and $L_2$ is a random variable that maps each of the units to their corresponding $3 \times 3$ grid (call this a county). Note that $Z = Z(1) + Z(2) + Z(3)$. 
\item Repeat the above to generate independent noise: generate $n = 729$ observations of $\zeta \sim \text{Expo}(1)$. Decompose $\zeta$ using the nested decomposition with three levels to obtain $\zeta = \zeta(1) + \zeta(2) + \zeta(3)$.
\item At each level $l= 1, 2, 3$ create $X(i)$ with the following formula: $$X(i) = \rho_i Z(i) + \sqrt{1-\rho_i^2}\zeta(i)$$ using $\rho = (0.9, 0.5, 0.001)$.
\item Construct $X$ using the formula $X = X(1) + X(2) + X(3)$.
\item Let $Y = 2X -Z + \epsilon$ where $\epsilon \sim \mathcal{N}(0,1)$ independently.
\end{enumerate}
By construction, $X,Z$ are nearly uncorrelated within the counties of $3 \times 3$, but correlated both within the states of $9 \times 9$ and across states. 

For each of the 100 scenarios, we decompose $X,Z,Y$ at different spatial scales using 1) nested decomposition and 2) spectral decomposition. At each spatial scale $\omega$, we obtain an estimate $\hat{\beta}(\omega)$ of $\beta =2$ from a linear regression of $Y(\omega)$ on $X(\omega)$. Hypothesis: $\hat{\beta}(\omega)$ is unbiased at $\omega$ corresponding to finer spatial scales since by construction confounding dissipates locally.


```{r, sim1, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/nesteddgm.jpeg", height = 600, width = 1300, res = 200)
plotfunc(nestedmat = out[[1]]$nestedmat, spectralmat = out[[1]]$spectralmat, 
         mains = c('Nested: Ground Truth', 'Spectral: Estimation'))
dev.off()
```

\newpage
# Simulation 2: Spectral DGM
We repeat the above but using the spectral decomposition to generate data.
\begin{enumerate}
\item Generate $n = 729$ observations of $Z \sim \text{Expo}(1)$.
\item Project $Z$ into the spectral domain using the spectral decomposition: 
$$Z^* = G^T Z$$
where $G$ is the graph Laplacian.
\item Repeat the above to generate independent noise: generate $n = 729$ observations of $\zeta \sim \text{Expo}(1)$. Project $\zeta$ into the spectral domain to obtain $\zeta^* = G^T \zeta$.
\item At each spectral frequency $\omega$ create $X^*$ with the following formula: $$X^*(\omega) = \rho_i Z^*(\omega) + \sqrt{1-\rho_i^2}\zeta^*(\omega)$$ using $\rho = (1, 727/728, \ldots, 1/728, 0)$. The frequencies ($n = 729$) are sorted lowest to highest, so that spatial scale is sorted highest to lowest. By construction, $X$ and $Z$ become less correlated at smaller scales. 
\item Construct $X$ using the formula $X = G X^*$.
\item Let $Y = 2X -Z + \epsilon$ where $\epsilon \sim \mathcal{N}(0,1)$ independently.
\end{enumerate}

Again, for each of the 100 scenarios we decompose $X,Z,Y$ at different spatial scales using 1) nested decomposition and 2) spectral decomposition. At each spatial scale $\omega$, we obtain an estimate $\hat{\beta}(\omega)$ of $\beta =2$ from a linear regression of $Y(\omega)$ on $X(\omega)$. Hypothesis:  $\hat{\beta}(\omega)$ is unbiased at $\omega$ corresponding to finer spatial scales since by construction confounding dissipates locally.

```{r, sim3, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/spectraldgm1.jpeg", height = 600, width = 1300, res = 200)
plotfunc(nestedmat = out[[3]]$nestedmat, spectralmat = out[[3]]$spectralmat, 
         mains = c('Nested: Estimation', 'Spectral: Ground Truth'))
dev.off()
```

Looking at the spectral plot, it's reassuring to see that the bias of the coefficient is $0$ at low spatial scales when the DGM is indeed spectral. The estimates obtained from the nested decomposition are biased at all of the grid levels. I think this makes sense: by construction the covariance is continuously decreasing with spatial scale; within a $3 \times 3$ grid we will observe bias. Let's try $\rho_i = 0$ for all but the $100$ lowest frequencies (100 largest scales).

```{r, sim4, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/spectraldgm2.jpeg", height = 600, width = 1300, res = 200)
plotfunc(nestedmat = out[[4]]$nestedmat, spectralmat = out[[4]]$spectralmat, 
         mains = c('Nested: Estimation', 'Spectral: Ground Truth'))
dev.off()
```

We observe less bias.

\newpage
# Simulation 3: Correlation by Spatial Scale
Let's plot the correlation between $X$ and $Z$ by spatial scale for both decompositions using the setup from simulation 1 (nested decomposition, $\rho = (0.9, 0.5, 0.001)$).

```{r, sim5, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/cornesteddgm.jpeg", height = 600, width = 1300, res = 200)
plotfunc(nestedmat = out[[5]]$nestedmat, 
                     spectralmat = out[[5]]$spectralmat,
                     ylab='Cor(X,Z)',
                     hline=0,
                     ylim=c(-1,1),
                     col='purple', 
         mains = c('Nested: Ground Truth', 'Spectral: Estimation'))
dev.off()
```

Now, let's plot the correlation between $X$ and $Z$ by spatial scale for both decompositions using the setup from simulation 2 (spectral decomposition, $\rho = (1, 727/728, \ldots, 1/728, 0)$).

```{r, sim7, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/corspectraldgm.jpeg", height = 600, width = 1300, res = 200)
plotfunc(nestedmat = out[[7]]$nestedmat, 
                     spectralmat = out[[7]]$spectralmat,
                     ylab='Cor(X,Z)',
                     hline=0,
                     ylim=c(-1.1,1.1),
                     col='purple', 
         mains = c('Nested: Estimation', 'Spectral: Ground Truth'))
dev.off()
```

```{r}
png("images/corspectraldgm2.jpeg", height = 600, width = 1300, res = 200)
plotfunc(nestedmat = out[[15]]$nestedmat, 
                     spectralmat = out[[15]]$spectralmat,
                     ylab='Cor(X,Z)',
                     hline=0,
                     ylim=c(-1.1,1.1),
                     col='purple', 
         mains = c('Nested: Estimation', 'Spectral: Ground Truth'))
dev.off()
```


\newpage
# Simulation 4: Local Confounding
We repeat simulations 1 and 2 but now confounding dissipates at larger scales rather than smaller ones. 

```{r, sim9, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/localnested.jpeg", height = 600, width = 1300, res = 200)
plotfunc(nestedmat = out[[9]]$nestedmat, spectralmat = out[[9]]$spectralmat, 
         mains = c('Nested: Ground Truth', 'Spectral: Estimation'))
dev.off()
```


```{r, sim10, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/localspectral.jpeg", height = 600, width = 1300, res = 200)
plotfunc(
  nestedmat = out[[10]]$nestedmat,
  spectralmat = out[[10]]$spectralmat,
  mains = c('Nested: Estimation', 'Spectral: Ground Truth')
)
dev.off()
```

\newpage
# Simulation 5: Outcome Model with Interaction
We repeat simulation 1 and 2 but the outcome model now includes an interaction term between $X$ and $Z$. In particular, let $Y = 2X -Z - XZ + \epsilon$. 

**Nested DGM**

```{r, sim11, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/interaction_nested.jpeg", height = 600, width = 1300, res = 200)
plotfunc(
  nestedmat = out[[11]]$nestedmat,
  spectralmat = out[[11]]$spectralmat,
  ylim = c(-4, 4),
  mains = c('Nested: Ground Truth', 'Spectral: Estimation')
)
dev.off()
```

The bias of the estimates is worse at higher scales but still zero bias at low scales.

**Spectral DGM**

```{r, sim12, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/interaction_spectral.jpeg", height = 600, width = 1300, res = 200)
plotfunc(
  nestedmat = out[[12]]$nestedmat,
  spectralmat = out[[12]]$spectralmat,
  ylim = c(-5, 5),
  mains = c('Nested: Estimation', 'Spectral: Ground Truth')
)
dev.off()
```

The bias of the estimates is the same as the results without an interaction... CHECK THIS

\newpage
# Simulation 6: Nonlinear Outcome Model
We repeat simulation 1 and 2 but the outcome model now includes a quadratic term of $X$. In particular, $Y = 2X + X^2 -Z + \epsilon$. The scale-specific analyses attempt to estimate both quadratic and linear coefficients of $X$. Neither method does a good job at recovering either of the coefficients.


**Nested DGM**

```{r, sim13, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/quadratic_nested.jpeg", height = 600, width = 1300, res = 200)
plotfunc(
  nestedmat = out[[13]]$nestedmats[, , 1],
  spectralmat = out[[13]]$spectralmats[, , 1],
  ylim = c(-10, 10),
  mains = c('Nested Linear: Ground Truth', 'Spectral Linear: Estimation')
)
dev.off()
```


```{r, sim131, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/quadratic_nested2.jpeg", height = 600, width = 1300, res = 200)
plotfunc(
  nestedmat = out[[13]]$nestedmats[, , 2],
  spectralmat = out[[13]]$spectralmats[, , 2],
  ylim = c(-10, 10),
  hline = 1,
  mains = c('Nested Quadratic: Ground Truth', 'Spectral Quadratic: Estimation')
)
dev.off()
```

\newpage
**Spectral DGM**

```{r, sim14, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/quadratic_spectral.jpeg", height = 600, width = 1300, res = 200)
plotfunc(
  nestedmat = out[[14]]$nestedmats[, , 1],
  spectralmat = out[[14]]$spectralmats[, , 1],
  ylim = c(-10, 10),
  mains = c('Nested Linear: Estimation', 'Spectral Linear: Ground Truth')
)
dev.off()
```

```{r, sim141, cache = T, echo = F, message = F, results = 'hide', warning = F}
png("images/quadratic_spectral2.jpeg", height = 600, width = 1300, res = 200)
plotfunc(
  nestedmat = out[[14]]$nestedmats[, , 2],
  spectralmat = out[[14]]$spectralmats[, , 2],
  hline = 1,
  ylim = c(-10, 10),
  mains = c('Nested Quadratic: Estimation', 'Spectral Quadratic: Ground Truth')
)
dev.off()
```


