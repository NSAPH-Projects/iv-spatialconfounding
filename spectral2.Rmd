---
title: "Spectral Decomposition"
author: "Sophie Woodward"
date: '2023-05-01'
output: pdf_document
---

# Task 1: time series only (1D), recode spec.pgram for my own understanding
```{r}
coherence1d = function(x, spans){ # let x be union of time series eg ts.union(mdeaths, fdeaths)
  # spans is a like smoothing parameter 
  xfreq = frequency(x)
  nser = ncol(x)
  N = nrow(x)
  kernel = kernel("modified.daniell", spans%/%2)
  Nspec = floor(N/2)
  freq = seq.int(from = xfreq/N, by = xfreq/N, length.out = Nspec)
  xfft = mvfft(x)
  pgram = array(NA, dim = c(N, nser, nser))
  for (i in 1:nser){
    for (j in 1:nser){
      pgram[,i,j] = xfft[,i]*Conj(xfft[,j])/(N*xfreq)
      #pgram[1, i, j] <- 0.5 * (pgram[2, i, j] + pgram[N, 
                #i, j])
    }
  }
  for (i in 1:nser){
    for (j in 1:nser){
      pgram[,i,j] = kernapply(pgram[,i,j],kernel, circular = T)
    }
  }
  pgram <- pgram[2:(Nspec + 1), , , drop = FALSE]
  spec = matrix(NA, nrow = Nspec, ncol = nser)
  for (i in 1:nser){
    spec[,i] = Re(pgram[1:Nspec,i,i])
  }
  print(dim(pgram))
  coh = matrix(NA, nrow = Nspec, ncol = nser*(nser-1)/2) # nser choose 2
  for (i in 1:(nser-1)){
    for (j in (i+1):nser){
      coh[, i + (j - 1) * (j - 2)/2] = Mod(pgram[,i, j])^2/(spec[, i] * spec[, j])
    }
  }
  return(list(freq,coh))
}

par(mfrow = c(1,2))
p = coherence1d(ts.union(mdeaths,fdeaths), spans = 8)
plot(p[[1]], p[[2]]^2, xlab = 'frequency', ylab = 'squared coherency', type = 'l', ylim = c(0,1))

# Comparison to native method
mfdeaths.spc = spec.pgram(ts.union(mdeaths, fdeaths), spans = 8, plot = F)
plot(mfdeaths.spc, plot.type = "coherency")

# Looks similar - diff because I did not include some other parameters like detrend/taper?
```

# Task 2: coherence for 2d time series
```{r}
# now x and z are MATRICES. start with nxn temporarily assume only one observation of the spatial series
coherence2d = function(x,z, n, spans){ # assume nrow(xi) = ncol(xi), for all i where xi is ith realization of x
  kernel = kernel("modified.daniell", spans%/%2)
  xfft = fft(x)
  zfft = fft(z)
  pgram = array(NA, dim = c(n, n, 2, 2))
  for (i in 1:2){ # x or z
    if (i == 1){
      x1 = xfft
    }
    else{
      x1 = zfft
    }
    for (j in 1:2){ # x or z
      if (j == 1){
        x2 = xfft
      }
      else{
        x2 = zfft
      }
      for (l in 1:n){ # row of grid
        for (k in 1:n){ # column
          pgram[l,k,i,j] = x1[l,k]*Conj(x2[l,k])/n^2 #/HELP (N*xfreq) # denominator is number of replications of series
        }
      }
    }
  }
  for (i in 1:2){
    for (j in 1:2){
      pgram[,,i,j] = kernapply(pgram[,,i,j],kernel, circular = T) # should take in a matrix
    }
  }
  #pgram <- pgram[2:(Nspec + 1), , , drop = FALSE] # removed this line for now
  spec = array(NA, dim = c(n,n,2))#nrow = n, ncol = nser)
  for (i in 1:2){
    spec[,,i] = Re(pgram[1:n,1:n,i,i])
  }
  coh = Mod(pgram[,,1, 2])^2/(spec[, ,1] * spec[, ,2])
  return(coh)
}
```

## Testing
```{r}
# Reusing simulation code from Reich's paper
n1    <- 40  # n1xn1 grid
n     <- n1^2 # n locations
lam   <- 0.95  
bX    <- 0.5
bZ    <- 0.5
sigma <- 0.25
sigx  <- sqrt(1.7)
sigz  <- sqrt(1.0)
bw = 1
bXZ = 1

# Define rook neighborhood structure 
s     <- expand.grid(1:n1,1:n1)
A     <- rdist(s)==1 # adjacency
R     <- diag(rowSums(A))-A # precision of ICAR
E     <- eigen(R) # eigen component
G     <- E$vec
D     <- E$val
W     <- exp(-(rdist(s)/bw)^2)
W     <- sweep(W,1,rowSums(W),"/")
nsims = 100
outXstar <- c()
outZstar <- c()
outcor <- c()
for(sim in 1:nsims){
    set.seed(sim)
    w    <- 1/sqrt(1-lam+lam*D)
    X    <- sigx*G%*%rnorm(n,0,w) # simulate X from Leroux CAR model
    Z    <- bXZ*W%*%X + sigz*G%*%rnorm(n,0,w)
    Y    <- bX*X + bZ*Z + rnorm(n,0,sigma)
    
    # assume same adjacency structure and project all variables 
    # into the spectral domain using graph Fourier transform
    Xstar <- t(G)%*%X
    Zstar <- t(G)%*%Z
    outXstar <- cbind(outXstar,Xstar)
    outZstar <- cbind(outZstar,Zstar)
    outcor  <- c(outcor,cor(X,Z))
  }
  corest_design <- unlist(lapply(1:n,function(i) cor(outXstar[i,],outZstar[i,])))

  # since not yet accomodating more than one realization use the last replicate
p = coherence2d(matrix(X, nrow = n1, ncol = n1, byrow = F), matrix(Z, nrow = n1, ncol = n1, byrow = F), 
                n = 40, spans = 5)
filled.contour(1:40,1:40,p, nlevels = 10)
filled.contour(1:40, 1:40, matrix(corest_design, nrow = 40, ncol = 40, byrow = T))
```





